#!/usr/bin/env kxh_python
import re
import sys
import time
import shlex
import shutil
import socket
import getpass
import datetime
import argparse
import subprocess
import tempfile
from pathlib import Path


_logdir = '.sash_logs'
(Path.home() / _logdir).mkdir(exist_ok=True)

SLURM_SCRIPT = """#!/bin/bash
#SBATCH -p {args.partition}
#SBATCH -o {logdir}/%j.out
#SBATCH -e {logdir}/%j.err
#SBATCH -N {args.node_count}
#SBATCH --cpus-per-task={cpus}
#SBATCH --time={args.time}
#SBATCH --gres={gres}
{sbatch_extra}

sleep 10
{queue_cmd}
cd $HOME
echo "date: $(date '+%Y-%m-%d %H:%M:%S')"
echo "hostname: $(hostname)"
echo "port: {port}"
{acmd}
# autossh to keep the reverse ssh connection alive
{autossh} \\
    -M 0 \\
    -o 'ServerAliveInterval 30' -o 'ServerAliveCountMax 3' -N \\
    -R {port}:localhost:22 \\
    {args.host}
sleep {time_in_seconds}
"""


def check_connection(port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0


def first_unused_port(start_port, end_port):
    for port in range(start_port, end_port + 1):
        if not check_connection(port):
            return port
    raise RuntimeError("No unused port available.")


def submit_slurm_job(args):
    print(f"date: {datetime.datetime.now():%Y-%m-%d %H:%M:%S}")
    port_range = [int(p) for p in args.port_range.split('-')]
    if len(port_range) == 1:
        port = port_range[0]
        if check_connection(port):
            raise RuntimeError(
                f"Port {port!r} is not available, "
                f"please choose another port.")
    elif len(port_range) == 2:
        port = first_unused_port(*port_range)
    else:
        raise ValueError(
            f"Invalid port range {args.port_range!r}, "
            f"should be in the format of '<int>' or '<int>-<int>'.")
    autossh = shutil.which('autossh')
    if not autossh:
        raise RuntimeError(
            "autossh is not found, please install it first.")
    sbatch_extra = ''
    if args.node:
        sbatch_extra += f"""#SBATCH -w {args.node}\n"""
    try:
        gpus = int(args.gres.split(':')[-1])
        cpus = int(args.cpus_per_gpu) * gpus
    except ValueError:
        gpus = 0
        cpus = int(args.cpus_per_gpu)
    queue_cmd = ' '.join(sys.argv)
    acmd = [shlex.quote(a) for a in args.additional_command]
    acmd = [re.sub(r"^'", r'"', a) for a in acmd]
    acmd = [re.sub(r"'$", r'"', a) for a in acmd]
    acmd = ' '.join(acmd)
    time_in_seconds = 604800  # 7 days
    script = SLURM_SCRIPT.format(
        logdir=_logdir, autossh=autossh, args=args, port=port, gres=args.gres,
        cpus=cpus, sbatch_extra=sbatch_extra, queue_cmd=queue_cmd, acmd=acmd,
        time_in_seconds=time_in_seconds)
    print(f"args: {args!r}")
    print(f"port: {port!r}")
    print(f"autossh: {autossh!r}")
    temp_file = tempfile.NamedTemporaryFile(
        prefix='sash_', mode='w', delete=True)
    with temp_file as f:
        f.write(script)
        f.flush()
        print(f"--- SLURM SCRIPT [{f.name}] ---")
        print(script)
        print("--- END SLURM SCRIPT ---")
        bargs = args.sbatch_args.strip().strip('"')
        bargs = shlex.split(args.sbatch_args)
        cmd = ['sbatch'] + list(bargs) + [f.name]
        print(f"command: {' '.join(cmd)}")
        output = subprocess.check_output(cmd, cwd=Path().home())
    jobid = output.decode().split()[-1]
    print(f"jobid: {jobid}")
    cmd = ['squeue', '-h', '-j', jobid, '-o', '%T;%R']
    print ('Now waiting for the job to start...')
    time.sleep(1)
    status, node = subprocess.check_output(cmd).decode().split(';')
    status = status.strip().lower()
    node = node.strip()
    print(f"status: {status}")
    if args.now and status != 'running':
        print(
            f'Job failed to start, reason {node}, cancelling job {jobid}...')
        subprocess.run(['scancel', jobid], check=True)
        return 1
    if status == 'running':
        print(f"node: {node}")
        print('You can now connect to the host with:')
        print(f"ssh {login_host().replace('login', node)}")
    else:
        print('When the job is running, you can connect to the host with:')
        print(f'ssh localhost -p {port}')
    return 0


def login_host():
    domain = '.'.join(socket.gethostname().split('.')[1:])
    return f'login.{domain}'


def parse_args():
    parser = argparse.ArgumentParser(
        description='Submit a reverse SSH job to SLURM.')
    default_host = f'{getpass.getuser()}@{login_host()}'
    parser.add_argument(
        '-s', '--host', type=str, default=default_host,
        help=f'Host to connect to, default: {default_host!r}.')
    parser.add_argument(
        '-p', '--partition', type=str, default='gpu',
        help='Partition to submit to.')
    parser.add_argument(
        '-N', '--node-count', type=int, default=1, help='Number of nodes.')
    parser.add_argument(
        '-c', '--cpus-per-gpu', type=int, default=16, help='Number of CPU cores.')
    parser.add_argument(
        '-g', '--gres', type=str, default='gpu:a100-sxm4-80gb:1')
    parser.add_argument(
        '-w', '--node', type=str, default=None)
    parser.add_argument(
        '-t', '--time', type=str, default='7-0:00',
        help='Time limit for the job.')
    parser.add_argument(
        '-r', '--port-range', type=str, default="30101-30199",
        help='Port number on host to expose, '
        'assigned from 30101-30199 if not specified.')
    parser.add_argument(
        '-a', '--sbatch-args', type=str, default='',
        help='Additional arguments to pass to sbatch.')
    parser.add_argument(
        '-n', '--now', action='store_true',
        help='If set, the job will either start or fail immediately.')
    parser.add_argument(
        '-q', '--queue-recursively', action='store_true',
        help='Queue another job recursively.')
    argv = sys.argv[1:]
    try:
        split_pos = argv.index('--')
        argv, command = argv[:split_pos], argv[split_pos + 1:]
    except ValueError:
        command = []
    args = parser.parse_args(argv)
    args.additional_command = command
    return args


def main(args=None):
    sys.exit(submit_slurm_job(args or parse_args()))


if __name__ == '__main__':
    main()
