#!/usr/bin/env kxh_python
import os
import re
import sys
import copy
import shutil
import argparse
import subprocess

import tomlkit
from cryptography.fernet import Fernet


SSH = shutil.which('ssh')


_quote_pos = re.compile('(?=[^-0-9a-zA-Z_./\n])')

def quote(arg):
    r"""
    >>> quote('\t')
    '\\\t'
    >>> quote('foo bar')
    'foo\\ bar'
    """
    # This is the logic emacs uses
    if arg:
        return _quote_pos.sub('\\\\', arg).replace('\n',"'\n'")
    return "''"


def highlight(src, lang):
    import pygments
    from pygments.formatters import TerminalFormatter
    from pygments.lexers.configs import TOMLLexer
    if lang == 'toml':
        lexer = TOMLLexer()
    else:
        raise ValueError(f'Unknown language: {lang!r}')
    formatter = TerminalFormatter()
    return pygments.highlight(src, lexer, formatter).strip('\n')


def add_border(title, hl_title, src, hl_src):
    hl_title = hl_title or title
    hl_src = hl_src or src
    width = max(len(l) for l in src.split('\n'))
    width = max(width, len(title))
    lines = ['╭─' + '─' * width + '─╮']
    if title:
        lines.append('│ ' + hl_title + ' ' * (width - len(title)) + ' │')
        lines.append('├─' + '─' * width + '─┤')
    for hl_line, line in zip(hl_src.split('\n'), src.split('\n')):
        lines.append('│ ' + hl_line + ' ' * (width - len(line)) + ' │')
    lines.append('╰─' + '─' * width + '─╯')
    return '\n'.join(lines)


class KxhArgumentParser(argparse.ArgumentParser):
    _USAGE = """
    kxh [-h | --help]
        [+d | ++dry] [+v | ++verbose] [+D | ++debug] [+F | ++force-reinstall]
        [+f | ++fast] [(+N | ++name) NAME] [(+r | ++rc) RC]
        [(+h | ++hermetic) | (+s | ++semi-hermetic) | (+n | ++non-hermetic)]
        [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address]
        [-c cipher_spec] [-D [bind_address:]port] [-E log_file]
        [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file]
        [-J destination] [-L address] [-l login_name] [-m mac_spec]
        [-O ctl_cmd] [-o option] [-P tag] [-p port] [-Q query_option]
        [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]
        [destination[:port]] [-- command [argument ...]]

Options:
    +v, ++verbose: verbose mode.
    +d, ++dry: dry run.
    +D, ++debug: debug mode.
    +F, ++force-reinstall: force reinstall on remote host.
    +f, ++fast: skip file sync.
    (+r | ++rc) RC: use custom RC file.
    (+N | ++name) NAME: use custom name instead of "kxh".
    +h, ++hermetic: use hermetic mode (default).
    +s, ++semi-hermetic: use semi-hermetic mode.
    +n, ++non-hermetic: use non-hermetic mode.
"""

    def __init__(self):
        super().__init__()
        store_true = {'action': 'store_true'}
        self.kxh_options = {
            ('d', 'dry'): store_true,
            ('v', 'verbose'): store_true,
            ('D', 'debug'): store_true,
            ('F', 'force-reinstall'): store_true,
            ('f', 'fast'): store_true,
            ('h', 'hermetic'): store_true,
            ('s', 'semi-hermetic'): store_true,
            ('n', 'non-hermetic'): store_true,
            ('N', 'name'): {'type': str, 'default': None},
            ('r', 'rc'): {'type': str, 'default': None},
        }
        for options, kwargs in self.kxh_options.items():
            dest = f"kxh_{options[-1].replace('-', '_')}"
            options = [f'--kxh-{o}' for o in options]
            self.add_argument(*options, dest=dest, **kwargs)
        for option in '46AaCfGgKkMNnqsTtVvXxYy':
            self.add_argument(f'-{option}', action='store_true')
        for option in 'BbcDEeFIiJLlmOoPpQRSWw':
            self.add_argument(f'-{option}', dest=option)
        self.add_argument('destination', type=str)

    def parse_args(self, args=None, namespace=None):
        args = args or sys.argv[1:]
        if '-h' in args or '--help' in args:
            self.print_usage()
            exit(0)
        normalized_args = []
        command_args = []
        parse_command = False
        for a in args:
            if parse_command:
                command_args.append(a)
                continue
            if a.startswith('++'):
                a = a.replace('-', '_')
                normalized_args.append(f'--kxh-{a.lstrip("+")}')
            elif a.startswith('+'):
                a = a.replace('-', '_')
                for af in a.lstrip('+'):
                    normalized_args.append(f'--kxh-{af}')
            elif a == '--':
                parse_command = True
            else:
                normalized_args.append(a)
        ssh_args = super().parse_args(normalized_args, namespace)
        ssh_args.command = command_args
        kxh_args = argparse.Namespace()
        for k, v in dict(vars(ssh_args)).items():
            if k.startswith('kxh_'):
                setattr(kxh_args, k[4:], v)
                delattr(ssh_args, k)
        mode = 'hermetic'
        if kxh_args.semi_hermetic:
            mode = 'semi-hermetic'
        if kxh_args.non_hermetic:
            mode = 'non-hermetic'
        kxh_args.mode = mode
        del kxh_args.hermetic
        del kxh_args.semi_hermetic
        del kxh_args.non_hermetic
        if ':' in ssh_args.destination:
            dest, port = ssh_args.destination.split(':')
            ssh_args.destination = dest
            ssh_args.p = port
        return kxh_args, ssh_args

    def unparse_ssh_args(self, parsed_args, dest=True):
        if not isinstance(parsed_args, dict):
            parsed_args = vars(parsed_args)
        command_line = [SSH]
        for option in '46AaCfGgKkMNnqsTtVvXxYy':
            if parsed_args.get(option):
                command_line.append(f'-{option}')
        for option in 'BbcDEeFIiJLlmOoPpQRSWw':
            value = parsed_args.get(option)
            if value is not None:
                command_line.append(f'-{option}')
                command_line.append(str(value))
        if dest:
            command_line.append(parsed_args['destination'])
        return command_line

    def print_usage(self):
        print(f'Usage:\n{self._USAGE}')

    def error(self, message):
        self.print_usage()
        print(message.replace('--kxh-', '+'))
        exit(1)


def update(mapping, values):
    for k, v in values.items():
        if v is None:
            pass
        elif isinstance(v, bool):
            mapping[k] = mapping.get(k) or v
        else:
            mapping[k] = v


class KXH:
    kxh_defaults = {
        'name': 'kxh',
        'repo': 'https://github.com/admk/dotfiles.git',
    }

    def _load_rc(self, rc):
        rc = rc or os.path.join(self.config_home, 'kxh.toml')
        if rc is not None:
            if not os.path.exists(rc):
                print(f'kxh: {rc!r} does not exist.', file=sys.stderr)
                exit(1)
            with open(rc, 'rb') as f:
                config = tomlkit.load(f).unwrap()
        else:
            config = {}
        config.setdefault('kxh', copy.deepcopy(self.kxh_defaults))
        if 'key' not in config['kxh']:
            config['kxh']['key'] = Fernet.generate_key().decode('utf-8')
        config.setdefault('ssh', {})
        return config

    def __init__(self):
        super().__init__()
        self.config_home = os.environ.get('XDG_CONFIG_HOME', '~/.config')
        self.cache_home = os.environ.get('XDG_CACHE_HOME', '~/.cache')
        parser = KxhArgumentParser()
        kxh_args, ssh_args = parser.parse_args()
        config = self._load_rc(kxh_args.rc)
        update(config.setdefault('kxh', {}), vars(kxh_args))
        ssh_args = {
            k: v for k, v in vars(ssh_args).items() if v is not False}
        update(config.setdefault('ssh', {}), ssh_args)
        self.ssh_cmd = parser.unparse_ssh_args(config['ssh'], dest=False)
        name = config['kxh']['name']
        if ' ' in name:
            print('KXH name cannot contain spaces.', file=sys.stderr)
            exit(1)
        home = os.environ.get('KXH_HOME', None)
        if not home:
            home = os.path.join(os.environ['HOME'], f'.{name}')
        config['kxh'].setdefault('home', home)
        if config['kxh']['verbose']:
            src = tomlkit.dumps(config)
            hl_src = highlight(src, 'toml')
            print(add_border('KXH Config', None, src, hl_src))
        self.config = config

    def _run(self, command, error_message=None, verbose=None, **kwargs):
        verbose = verbose if verbose is not None else self.config['kxh']['verbose']
        dry = self.config['kxh']['dry']
        if verbose or dry:
            print(f"kxh.run: {' '.join(command)}")
            err = sys.stderr
        else:
            err = subprocess.DEVNULL
        if dry:
            return
        try:
            output = subprocess.check_output(command, stderr=err, **kwargs)
        except subprocess.CalledProcessError as e:
            if error_message is not None:
                print(f'Error: {error_message}', file=sys.stderr)
                exit(1)
            else:
                raise e
        output = output.decode('utf-8')
        if verbose:
            print(output)
        return output

    def _run_shell(self, command, error_message=None, verbose=None, **kwargs):
        verbose = verbose if verbose is not None else self.config['kxh']['verbose']
        dry = self.config['kxh']['dry']
        if verbose or dry:
            print(f'kxh.run_shell: {command}')
        else:
            kwargs.setdefault('stdout', subprocess.DEVNULL)
        if dry:
            return
        try:
            subprocess.run(command, shell=True, **kwargs)
        except subprocess.CalledProcessError as e:
            if error_message is not None:
                print(f'Error: {error_message}', file=sys.stderr)
                exit(1)
            else:
                raise e

    def _ssh_host_specific_rcs(self):
        name = self.config['kxh']['name']
        key = self.config['kxh']['key']
        rcs_dir = os.path.join(self.config_home, name, 'hosts')
        os.makedirs(rcs_dir, exist_ok=True)
        cache_rcs_dir = os.path.join(self.cache_home, name, 'hosts')
        if os.path.exists(cache_rcs_dir):
            shutil.rmtree(cache_rcs_dir)
        shutil.copytree(rcs_dir, cache_rcs_dir)
        custom_rcs = []
        for rc in os.listdir(cache_rcs_dir):
            rc_file = os.path.join(cache_rcs_dir, rc)
            if not os.path.isfile(rc_file):
                continue
            rc_name = os.path.splitext(rc)[0]
            if re.match(rc_name, self.config['ssh']['destination']):
                custom_rcs.append(rc_file)
        rcs = []
        for rc in custom_rcs:
            with open(rc, 'r', encoding='utf-8') as r:
                rc = os.path.relpath(rc, self.config['kxh']['home'])
                rcs.append(f'# --- {rc} ---')
                rcs.append(r.read())
        rcs = '\n'.join(rcs)
        enc = Fernet(key).encrypt(rcs.encode('utf-8'))
        collate_rc = os.path.join(
            self.cache_home, name, 'hosts_collated.xsh.enc')
        with open(collate_rc, 'w', encoding='utf-8') as f:
            f.write(enc.decode('utf-8'))
        key_file = os.path.join(self.cache_home, name, 'key')
        with open(key_file, 'w', encoding='utf-8') as f:
            f.write(key)
        return [collate_rc, key_file]

    def _shared_files(self):
        name = self.config['kxh']['name']
        shared_dir = os.path.join(self.config_home, name, 'share')
        return [os.path.join(shared_dir, f) for f in os.listdir(shared_dir)]

    def _file_list_file(self):
        name = self.config['kxh']['name']
        sync_file = os.path.join(self.cache_home, name, 'sync')
        os.makedirs(os.path.dirname(sync_file), exist_ok=True)
        f = open(sync_file, 'w', encoding='utf-8')
        home = self.config['kxh']['home']
        file_list = self._run(
            ['git', 'ls-files'],
            f'Failed to list files in {home!r}.',
            verbose=False, cwd=home)
        file_list = file_list or ''
        custom_files = self._ssh_host_specific_rcs()
        custom_files += self._shared_files()
        files = [
            os.path.relpath(f, self.config['kxh']['home'])
            for f in custom_files]
        if self.config['kxh']['verbose']:
            print(f'Custom files: {custom_files}')
        files.append(os.path.relpath(sync_file, home))
        file_list += '\n'.join(files) + '\n'
        f.write(file_list)
        f.close()
        return sync_file

    def _sync_files(self):
        url = self.config['kxh']['repo']
        home = self.config['kxh']['home']
        name = self.config['kxh']['name']
        dest = self.config['ssh']['destination']
        if not os.path.exists(home):
            self._run(
                ['git', 'clone', url, home],
                f'Failed to clone {url!r} to {home!r}.')
        if self.config['kxh']['force_reinstall']:
            dest = self.config['ssh']['destination']
            ask = f'Force reinstall .{name} to {dest!r}? [y/N] '
            if input(ask) != 'y':
                exit(0)
            print(f'Reinstalling .{name}...')
            rm_cmd = f'rm -rf .{name} .local/bin/xh'
            self._run(
                self.ssh_cmd + [dest, rm_cmd],
                f'Failed to remove .{name!r} from {dest!r}.')
        file_list = self._file_list_file()
        rsync_cmd = [
            f"SHELL={shutil.which('bash')}",
            "rsync --archive --compress --human-readable",
            "--update --partial --progress --checksum",
            f"--rsh {' '.join(self.ssh_cmd)!r}",
            f"--files-from {file_list}",
            f"\'{home}/\' {dest}:.{name}"
        ]
        rsync_cmd = ' '.join(rsync_cmd)
        self._run_shell(
            rsync_cmd,
            f'Failed to rsync files to {dest!r}.')

    def _ssh(self):
        name = self.config['kxh']['name']
        mode = self.config['kxh']['mode']
        verbose = self.config['kxh']['verbose']
        debug = self.config['kxh']['debug']
        dest = self.config['ssh']['destination']
        port = self.config['ssh'].get('p')
        host = f'{dest}:{port}' if port else dest
        prefix = [
            f'KXH_HOST={host}',
            f'KXH_NAME={name}',
            f'KXH_MODE={mode}',
            f'KXH_VERBOSE={int(verbose)}',
            f'KXH_DEBUG={int(debug)}',
        ]
        init_script = f"env {' '.join(prefix)} "
        command = f'.{name}/.local/bin/_kxh_init'
        if cmd := self.config['ssh']['command']:
            cmd = " ".join(cmd)
            command += f' -c {cmd!r}'
        # command = command.replace('\\', '\\\\').replace(' ', '\\ ')
        # command = command.replace("'", "\\'").replace('"', '\\"')
        init_script += f"/bin/bash --norc -c {quote(command)!r}"
        ssh_cmd = self.ssh_cmd + ['-o', 'RequestTTY=yes', dest, init_script]
        self._run_shell(
            ' '.join(ssh_cmd), 'Failed to load ssh session.',
            stdout=sys.stdout, stderr=sys.stderr)

    def main(self):
        if not self.config['kxh']['fast']:
            self._sync_files()
        self._ssh()


if __name__ == '__main__':
    KXH().main()
