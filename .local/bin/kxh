#!/usr/bin/env python3
import os
import re
import sys
import shutil
import argparse
import subprocess
from enum import Enum


SSH = shutil.which('ssh')


class HermeticMode(Enum):
    HERMETIC = 0
    SEMI_HERMETIC = 1
    NON_HERMETIC = 2


class KxhArgumentParser(argparse.ArgumentParser):
    _USAGE = """
    kxh [-h | --help]
        [+d | ++dry] [+v | ++verbose] [+D | ++debug]
        [+f | ++force-reinstall]
        [(+h | ++hermetic) | (+s | ++semi-hermetic) | (+n | ++non-hermetic)]
        [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address]
        [-c cipher_spec] [-D [bind_address:]port] [-E log_file]
        [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file]
        [-J destination] [-L address] [-l login_name] [-m mac_spec]
        [-O ctl_cmd] [-o option] [-P tag] [-p port] [-Q query_option]
        [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]
        [destination[:port]] [command [argument ...]]

Options:
    +v, ++verbose: verbose mode.
    +d, ++dry: dry run.
    +D, ++debug: debug mode.
    +f, ++force-reinstall: remove the kxh folder to force reinstall.
    +h, ++hermetic: use hermetic mode (default).
    +s, ++semi-hermetic: use semi-hermetic mode.
    +n, ++non-hermetic: use non-hermetic mode."""

    def __init__(self):
        super().__init__()
        kxh_options = [
            ('d', 'dry'),
            ('v', 'verbose'),
            ('D', 'debug'),
            ('f', 'force-reinstall'),
            ('h', 'hermetic'),
            ('s', 'semi-hermetic'),
            ('n', 'non-hermetic'),
        ]
        for options in kxh_options:
            dest = f"kxh_{options[-1].replace('-', '_')}"
            options = [f'--kxh-{o}' for o in options]
            self.add_argument(*options, action='store_true', dest=dest)
        for option in '46AaCfGgKkMNnqsTtVvXxYy':
            self.add_argument(f'-{option}', action='store_true')
        for option in 'BbcDEeFIiJLlmOoPpQRSWw':
            self.add_argument(f'-{option}', dest=option)
        self.add_argument('destination', nargs='?', default='localhost')

    def parse_args(self, args=None, namespace=None):
        args = args or sys.argv[1:]
        if '-h' in args or '--help' in args:
            self.print_usage()
            exit(0)
        normalized_args = []
        for a in args:
            if a.startswith('++'):
                a = a.replace('-', '_')
                normalized_args.append(f'--kxh-{a.lstrip("+")}')
            elif a.startswith('+'):
                a = a.replace('-', '_')
                for af in a.lstrip('+'):
                    normalized_args.append(f'--kxh-{af}')
            else:
                normalized_args.append(a)
        ssh_args = super().parse_args(normalized_args, namespace)
        kxh_args = argparse.Namespace()
        for k, v in dict(vars(ssh_args)).items():
            if k.startswith('kxh_'):
                setattr(kxh_args, k[4:], v)
                delattr(ssh_args, k)
        hmode = HermeticMode.HERMETIC
        if kxh_args.semi_hermetic:
            hmode = HermeticMode.SEMI_HERMETIC
        if kxh_args.non_hermetic:
            hmode = HermeticMode.NON_HERMETIC
        kxh_args.hermetic_mode = hmode
        if ':' in ssh_args.destination:
            dest, port = ssh_args.destination.split(':')
            ssh_args.destination = dest
            ssh_args.p = port
        return kxh_args, ssh_args

    def unparse_ssh_args(self, parsed_args, dest=True):
        command_line = [SSH]
        for option in '46AaCfGgKkMNnqsTtVvXxYy':
            if getattr(parsed_args, option):
                command_line.append(f'-{option}')
        for option in 'BbcDEeFIiJLlmOoPpQRSWw':
            value = getattr(parsed_args, option)
            if value is not None:
                command_line.append(f'-{option}')
                command_line.append(str(value))
        if dest:
            command_line.append(parsed_args.destination)
        return command_line

    def print_usage(self):
        print(f'Usage:\n{self._USAGE}')

    def error(self, message):
        self.print_usage()
        print(message.replace('--kxh-', '+'))
        exit(1)


class KXH:
    name = 'kxh'
    url = 'https://github.com/admk/dotfiles.git'

    def __init__(self):
        super().__init__()
        if ' ' in self.name:
            print('KXH name cannot contain spaces.', file=sys.stderr)
            exit(1)
        self.dot_name = f'.{self.name}'
        self.home = os.environ.get('KXH_HOME', None)
        if not self.home:
            self.home = os.path.join(os.environ['HOME'], self.dot_name)
        self.config_home = os.path.join(
            os.environ.get('XDG_CONFIG_HOME', '~/.config'), self.name)
        self.cache_home = os.path.join(
            os.environ.get('XDG_CACHE_HOME', '~/.cache'), self.name)
        parser = KxhArgumentParser()
        kxh_args, ssh_args = parser.parse_args()
        self.ssh_cmd = parser.unparse_ssh_args(ssh_args, dest=False)
        for args in (kxh_args, ssh_args):
            for k, v in dict(vars(args)).items():
                if hasattr(self, k):
                    raise ValueError(f'Attribute {k!r} already exists.')
                setattr(self, k, v)

    def _run(self, command, error_message=None, verbose=None, **kwargs):
        verbose = verbose if verbose is not None else self.verbose
        if verbose or self.dry:
            print(f"kxh.run: {' '.join(command)}")
            err = sys.stderr
        else:
            err = subprocess.DEVNULL
        if self.dry:
            return
        try:
            output = subprocess.check_output(command, stderr=err, **kwargs)
        except subprocess.CalledProcessError as e:
            if error_message is not None:
                print(f'Error: {error_message}', file=sys.stderr)
                exit(1)
            else:
                raise e
        output = output.decode('utf-8')
        if verbose:
            print(output)
        return output

    def _run_shell(self, command, error_message=None, verbose=None, **kwargs):
        verbose = verbose if verbose is not None else self.verbose
        if verbose or self.dry:
            print(f'kxh.run_shell: {command}')
        else:
            kwargs.setdefault('stdout', subprocess.DEVNULL)
        if self.dry:
            return
        try:
            subprocess.run(command, shell=True, **kwargs)
        except subprocess.CalledProcessError as e:
            if error_message is not None:
                print(f'Error: {error_message}', file=sys.stderr)
                exit(1)
            else:
                raise e

    def _custom_rcs(self):
        rcs_dir = os.path.join(self.config_home, 'hosts')
        cache_rcs_dir = os.path.join(self.cache_home, 'hosts')
        if os.path.exists(cache_rcs_dir):
            shutil.rmtree(cache_rcs_dir)
        shutil.copytree(rcs_dir, cache_rcs_dir)
        for rc in os.listdir(cache_rcs_dir):
            rc_file = os.path.join(cache_rcs_dir, rc)
            if not os.path.isfile(rc_file):
                continue
            rc_name = os.path.splitext(rc)[0]
            if re.match(rc_name, self.destination):
                yield os.path.relpath(rc_file, self.home)

    def _file_list_file(self):
        file = os.path.join(self.cache_home, f'sync')
        f = open(file, 'w')
        file_list = self._run(
            ['git', 'ls-files'],
            f'Failed to list files in {self.home!r}.',
            verbose=False, cwd=self.home)
        file_list = file_list or ''
        custom_rcs = list(self._custom_rcs())
        if self.verbose:
            print(f'Custom rc files: {(custom_rcs)}')
        file_list += '\n'.join(custom_rcs)
        rel_file = os.path.relpath(file, self.home)
        file_list += f'\n{rel_file}\n'
        f.write(file_list)
        f.close()
        return file

    def _sync_files(self):
        if not os.path.exists(self.home):
            self._run(
                ['git', 'clone', self.url, self.home],
                f'Failed to clone {self.url!r} to {self.home!r}.')
        if self.force_reinstall:
            ask = f'Force reinstall {self.dot_name!r} to {self.destination!r}? [y/N] '
            if input(ask) != 'y':
                exit(0)
            print(f'Reinstalling {self.dot_name!r}...')
            self._run(
                self.ssh_cmd + [self.destination, f'rm -rf {self.dot_name}'],
                f'Failed to remove {self.name!r} from {self.destination!r}.')
        file_list = self._file_list_file()
        rsync_cmd = [
            f"SHELL={shutil.which('bash')}",
            "rsync --archive --compress --human-readable",
            "--update --partial --progress --checksum",
            f"--rsh {' '.join(self.ssh_cmd)!r}",
            f"--files-from {file_list}",
            f"\'{self.home}/\' {self.destination}:{self.dot_name}"
        ]
        rsync_cmd = ' '.join(rsync_cmd)
        self._run_shell(
            rsync_cmd,
            f'Failed to rsync files to {self.destination!r}.')

    def _ssh(self):
        host = self.destination
        if self.p:
            host = f'{host}:{self.p}'
        prefix = [
            f'KXH_HOST={host!r}',
            f'KXH_NAME={self.name!r}',
            f'KXH_MODE={self.hermetic_mode.name.lower().replace("_", "-")}',
            f'KXH_VERBOSE={int(self.verbose)}',
            f'KXH_DEBUG={int(self.debug)}',
        ]
        init_script = f"env {' '.join(prefix)} "
        init_script += f'/bin/bash --norc -c {self.dot_name}/.local/bin/_kxh_init'
        ssh_cmd = self.ssh_cmd + [
            '-o', 'RequestTTY=yes', self.destination, repr(init_script)
        ]
        ssh_cmd = ' '.join(ssh_cmd)
        self._run_shell(
            ssh_cmd, 'Failed to load ssh session.',
            stdout=sys.stdout, stderr=sys.stderr)

    def main(self):
        self._sync_files()
        self._ssh()


if __name__ == '__main__':
    KXH().main()
