#!/usr/bin/env python3
import os
import sys
import tempfile
import argparse
import subprocess
from shutil import which
from enum import Enum


SSH = f"{which('ssh')}"


class HermeticMode(Enum):
    HERMETIC = 0
    SEMI_HERMETIC = 1
    NON_HERMETIC = 2


class KxhArgumentParser(argparse.ArgumentParser):
    _USAGE = """
    kxh [-h | --help]
        [+d | +dry] [+v | +verbose] [+f | +force-reinstall]
        [(+h | +hermetic) | (+s | +semi-hermetic) | (+n | +non-hermetic)]
        [-46AaCfGgKkMNnqsTtVvXxYy] [-B bind_interface] [-b bind_address]
        [-c cipher_spec] [-D [bind_address:]port] [-E log_file]
        [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file]
        [-J destination] [-L address] [-l login_name] [-m mac_spec]
        [-O ctl_cmd] [-o option] [-P tag] [-p port] [-Q query_option]
        [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]]
        [destination] [command [argument ...]]

Options:
    +v, +verbose: verbose mode.
    +h, +hermetic: use hermetic mode (default).
    +s, +semi-hermetic: use semi-hermetic mode.
    +n, +non-hermetic: use non-hermetic mode."""

    def __init__(self):
        super().__init__()
        kxh_options = [
            ('d', 'dry'),
            ('v', 'verbose'),
            ('f', 'force-reinstall'),
            ('h', 'hermetic'),
            ('s', 'semi-hermetic'),
            ('n', 'non-hermetic'),
        ]
        for options in kxh_options:
            dest = f"kxh_{options[-1].replace('-', '_')}"
            options = [f'--kxh-{o}' for o in options]
            self.add_argument(*options, action='store_true', dest=dest)
        for option in '46AaCfGgKkMNnqsTtVvXxYy':
            self.add_argument(f'-{option}', action='store_true')
        for option in 'BbcDEeFIiJLlmOoPpQRSWw':
            self.add_argument(f'-{option}', dest=option)
        self.add_argument('destination', nargs='?', default='localhost')

    def parse_args(self, args=None, namespace=None):
        args = args or sys.argv[1:]
        if '-h' in args or '--help' in args:
            self.print_usage()
            exit(0)
        normalized_args = []
        for a in args:
            if a.startswith('++'):
                a = a.replace('-', '_')
                normalized_args.append(f'--kxh-{a[2:]}')
            elif a.startswith('+'):
                a = a.replace('-', '_')
                for af in a[1:]:
                    normalized_args.append(f'--kxh-{af}')
            else:
                normalized_args.append(a)
        ssh_args = super().parse_args(normalized_args, namespace)
        kxh_args = argparse.Namespace()
        for k, v in dict(vars(ssh_args)).items():
            if k.startswith('kxh_'):
                setattr(kxh_args, k[4:], v)
                delattr(ssh_args, k)
        hmode = HermeticMode.HERMETIC
        if kxh_args.semi_hermetic:
            hmode = HermeticMode.SEMI_HERMETIC
        if kxh_args.non_hermetic:
            hmode = HermeticMode.NON_HERMETIC
        kxh_args.hermetic_mode = hmode
        return kxh_args, ssh_args

    def unparse_ssh_args(self, parsed_args, dest=True):
        command_line = [SSH]
        for option in '46AaCfGgKkMNnqsTtVvXxYy':
            if getattr(parsed_args, option):
                command_line.append(f'-{option}')
        for option in 'BbcDEeFIiJLlmOoPpQRSWw':
            value = getattr(parsed_args, option)
            if value is not None:
                command_line.append(f'-{option}')
                command_line.append(str(value))
        if dest:
            command_line.append(parsed_args.destination)
        return command_line

    def print_usage(self):
        print(f'Usage:\n{self._USAGE}')

    def error(self, message):
        self.print_usage()
        print(message.replace('--kxh-', '+'))
        exit(1)


class KXH:
    name = '.kxh'
    url = 'https://github.com/admk/dotfiles.git'

    def __init__(self):
        super().__init__()
        if ' ' in self.name:
            print('KXH name cannot contain spaces.', file=sys.stderr)
            exit(1)
        self.home = os.environ.get('KXH_HOME', None)
        if not self.home:
            self.home = os.path.join(os.environ['HOME'], self.name)
        parser = KxhArgumentParser()
        kxh_args, ssh_args = parser.parse_args()
        self.ssh_cmd = parser.unparse_ssh_args(ssh_args, dest=False)
        for args in (kxh_args, ssh_args):
            for k, v in dict(vars(args)).items():
                if hasattr(self, k):
                    raise ValueError(f'Attribute {k!r} already exists.')
                setattr(self, k, v)

    def _run(self, command, error_message=None, verbose=None, **kwargs):
        verbose = verbose if verbose is not None else self.verbose
        if verbose or self.dry:
            print(f"kxh.run: {' '.join(command)}")
            err = sys.stderr
        else:
            err = subprocess.DEVNULL
        if self.dry:
            return
        try:
            output = subprocess.check_output(command, stderr=err, **kwargs)
        except subprocess.CalledProcessError as e:
            if error_message is not None:
                print(f'Error: {error_message}', file=sys.stderr)
                exit(1)
            else:
                raise e
        output = output.decode('utf-8')
        if verbose:
            print(output)
        return output

    def _run_shell(self, command, error_message=None, verbose=None, **kwargs):
        verbose = verbose if verbose is not None else self.verbose
        if verbose or self.dry:
            print(f'kxh.run_shell: {command}')
        else:
            kwargs.setdefault('stdout', subprocess.DEVNULL)
        if self.dry:
            return
        try:
            subprocess.run(command, shell=True, **kwargs)
        except subprocess.CalledProcessError as e:
            if error_message is not None:
                print(f'Error: {error_message}', file=sys.stderr)
                exit(1)
            else:
                raise e

    def _sync_files(self):
        if not os.path.exists(self.home):
            self._run(
                ['git', 'clone', self.url, self.home],
                f'Failed to clone {self.url!r} to {self.home!r}.')
        if self.force_reinstall:
            print(f'Force reinstalling {self.name!r} to {self.destination!r}.')
            self._run(
                self.ssh_cmd + [self.destination, f'rm -rf {self.name}'],
                f'Failed to remove {self.name!r} from {self.destination!r}.')
        with tempfile.NamedTemporaryFile(mode='w+') as f:
            file_list = self._run(
                ['git', 'ls-files'],
                f'Failed to list files in {self.home!r}.',
                verbose=False, cwd=self.home)
            file_list = file_list or ''
            f.write(file_list)
            f.flush()
            rsync_cmd = [
                f"SHELL={which('bash')}",
                "rsync --archive --compress --human-readable",
                "--update --partial --progress --checksum",
                f"--rsh {' '.join(self.ssh_cmd)!r}",
                f"--files-from {f.name}",
                f"\'{self.home}/\' {self.destination}:{self.name}"
            ]
            rsync_cmd = ' '.join(rsync_cmd)
            self._run_shell(
                rsync_cmd,
                f'Failed to rsync files to {self.destination!r}.')

    def _ssh(self):
        prefix = [
            f'KXH_MODE={self.hermetic_mode.name.lower().replace("_", "-")}',
            f'KXH_VERBOSE={int(self.verbose)}'
        ]
        init_script = f"env {' '.join(prefix)} "
        init_script += f'bash -l -c {self.name}/.local/bin/_kxh_init'
        ssh_cmd = self.ssh_cmd + [
            '-o', 'RequestTTY=yes', self.destination, repr(init_script)
        ]
        ssh_cmd = ' '.join(ssh_cmd)
        self._run_shell(
            ssh_cmd, 'Failed to load ssh session.',
            stdout=sys.stdout, stderr=sys.stderr)

    def main(self):
        self._sync_files()
        self._ssh()


if __name__ == '__main__':
    KXH().main()
