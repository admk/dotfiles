#!/usr/bin/env python3
import sys
import json
import shlex
import argparse
import datetime
import subprocess

import tqdm


STATUSES = ['running', 'allocating', 'success', 'failed', 'killed']


def _parse_args(args=None):
    parser = argparse.ArgumentParser()
    options = {
        ('action', ): {
            'choices': [
                'ids', 'json', 'info', 'cancel', 'rerun', 'requeue', 'remove',
            ],
            'help': 'Action to perform.',
        },
        ('-i', '--id'): {
            'type': str,
            'default': None,
            'help':
                'The ranges of job IDs to perform the action on, '
                'a comma-separated list of ranges, e.g. "1-3,5,7-9". '
                'If not provided, all jobs will be affected.',
        },
        ('-r', '--running'): {
            'action': 'store_true',
            'help': 'Perform the action on running jobs.',
        },
        ('-a', '--allocating'): {
            'action': 'store_true',
            'help': 'Perform the action on allocating jobs.',
        },
        ('-s', '--success'): {
            'action': 'store_true',
            'help': 'Perform the action on successful jobs.',
        },
        ('-f', '--failed'): {
            'action': 'store_true',
            'help': 'Perform the action on failed jobs.',
        },
        ('-k', '--killed'): {
            'action': 'store_true',
            'help': 'Perform the action on killed jobs.',
        },
        ('-c', '--commit'): {
            'action': 'store_true',
            'help':
                'Print the command that would be executed, but do not '
                'execute it.',
        },
    }
    for option, kwargs in options.items():
        parser.add_argument(*option, **kwargs)
    args = parser.parse_args(args)
    # extract the range of job IDs
    if args.id:
        args.id = args.id.split(',')
        ids = []
        for i in args.id:
            if '-' in i:
                start, end = i.split('-')
                ids += list(range(int(start), int(end) + 1))
            else:
                ids.append(int(i))
        args.id = ids
    # If no statuses are specified, default to all.
    args.all = all([not getattr(args, a) for a in STATUSES])
    return args


def _ts(*args, commit=True):
    cmd = ['ts'] + [str(a) for a in args]
    if not commit:
        print(cmd)
        return
    p = subprocess.run(cmd, capture_output=True)
    return p.stdout.decode('utf-8')


def _ts_job_info(args):
    info = {}
    for l in _ts().splitlines()[1:]:
        l = l.strip().split()
        if l[1] == 'finished':
            id, status, _, exitcode, gpus, *_ = l
            exitcode = int(exitcode)
            if exitcode == 0:
                status = 'success'
            elif exitcode < 0:
                status = 'killed'
            else:
                status = 'failed'
        else:
            id, status, _, gpus, *_ = l
            exitcode = None
        info[int(id)] = {
            'status': status,
            'gpus': gpus,
            'exitcode': exitcode
        }
    if not args.all:
        for a in ['running', 'allocating', 'success', 'failed', 'killed']:
            if not getattr(args, a):
                info = {k: v for k, v in info.items() if v['status'] != a}
    if args.id:
        info = {k: v for k, v in info.items() if k in args.id}
    return {k: info[k] for k in sorted(info)}


def tsu_ids(args):
    for i in _tsu_info(args):
        print(i)


def _tsu_info(args):
    def get_line(job_info, key):
        for l in job_info.splitlines():
            if key in l:
                return l.replace(key, '').strip()
        return None

    def get_time(job_info, key):
        time = get_line(job_info, key)
        if not time:
            return None
        return datetime.datetime.strptime(time, '%a %b %d %H:%M:%S %Y')

    info = _ts_job_info(args)
    for i in info:
        job_info = _ts('-i', i)
        new_info = {
            'command': get_line(job_info, 'Command: '),
            'slots_required': int(get_line(job_info, 'Slots required: ')),
            'gpus_required': int(get_line(job_info, 'GPUs required: ')),
            'gpu_ids': get_line(job_info, 'GPU IDs: '),
            'enqueue_time': get_time(job_info, 'Enqueue time: '),
            'start_time': get_time(job_info, 'Start time: '),
            'end_time': get_time(job_info, 'End time: '),
            'time_run':
                get_line(job_info, 'Time running: ') or
                get_line(job_info, 'Time run: '),
        }
        info[i].update({k: v for k, v in new_info.items() if v is not None})
    return info


def tsu_json(args):
    print(json.dumps(_tsu_info(args), indent=4, default=str))


def tsu_info(args):
    info = _tsu_info(args)
    for k, v in info.items():
        print(f'Job {k}:')
        for k, v in v.items():
            print(f'  {k}: {v}')


def tsu_rerun(args):
    if args.all:
        print('tsu: flags must be specified for rerun.')
        sys.exit(1)
    iterer = tqdm.tqdm(_tsu_info(args).items())
    reran_ids = []
    for i, info in iterer:
        reran_ids += [i]
        iterer.set_description(f'Requeueing {i}')
        torun = []
        if gpus := info['gpus_required']:
            torun += ['-G', gpus]
        if slots := info['slots_required']:
            torun += ['-N', slots]
        torun += shlex.split(info['command'])
        _ts(*torun, commit=args.commit)
    return reran_ids


def _tsu_remove(ids, commit):
    iterer = tqdm.tqdm(ids)
    for i in iterer:
        iterer.set_description(f'Removing {i}')
        _ts('-r', i, commit=commit)


def tsu_requeue(args):
    if args.all:
        print('tsu: flags must be specified for requeue.')
        sys.exit(1)
    reran_ids = tsu_rerun(args)
    _tsu_remove(reran_ids, args.commit)


def tsu_remove(args):
    _tsu_remove(_ts_job_info(args), args.commit)


def main():
    args = _parse_args()
    try:
        func = getattr(sys.modules[__name__], f'tsu_{args.action}')
    except AttributeError:
        print(f'Invalid action: {args.action}')
        sys.exit(1)
    func(args)


if __name__ == '__main__':
    main()
